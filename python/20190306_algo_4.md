### 이진 탐색 by 재귀

시간복잡도

이진 탐색을 반복문으로 구현할 때와 마찬가지로 탐색 범위가 반 씩 줄어들기 때문에, 시간 복잡도는 lg(n)





### 하노이의 탑 by 재귀

총 3개의 기둥이 있고 첫번째 기둥에 작은 원판이 위에 있도록 순서대로 쌓여져 있다. 첫번째 기둥이 있는 원판들을 마지막 기둥으로 옮겨야하며 최종적으로 동일한 순서를 유지해야 한다. 이때 다음 두 가지 조건을 만족시켜야 한다.

1. 한 번에 하나의 원판만 옮길 수 있다.
2. 큰 원판이 작은 원판 위에 있어서는 안 된다.

하노이 타워 문제에도 재귀적 사고를 적용해보자.

1. 일단 n번째 즉 제일 마지막 원판이 마지막 기둥 제일 아래에 위치시켜야 한다. 이것을 위해서는 n-1개의 원판은 중간 기둥에 모두 옮겨져 있어야 한다.
2. 중간 기둥에 있는 n-1개의 원판중 n-1번째 원판을 마지막 기둥으로 옮겨야한다. 이것을 위해서는 n-2개의 원판을 비어있는 첫번째 원판으로 옮겨야한다.
3. …이런 반복이 무한하게 반복된다. 여기서 각 단계 마다의 탈출 조건(Base case)은 옮겨야할 원판이 아무것도 없다면 종료될 것이다.



```python
def hanoi(n, start, waypoint, destination):
  if n == 0:
      # 탈출 조건
      return
  # 크게 두번 옮긴다.
  # 1. 일단 n-1까지를 출발 기둥(Start)에서 중간 기둥(Waypoint)을 거쳐 도착 기동(Destination)으로 옮긴다.
  hanoi(n - 1, start, destination, waypoint)
  # 2. 그리고 출발 기둥(Start)에 남아있는 n번째(제일 큰) 원판을 도착 기동(Destination)기둥으로 바로 옯긴다.
  print('{} move {} => {}'.format(n, start, destination))
  # 3. 중간 기둥(Waypoint)에 남아있는 n-1까지들을 다시 출발 기둥(Start)를 겨처 도착 기동(Destination)으로 옮긴다.
  hanoi(n - 1, waypoint, start, destination)
```

출처:https://grepsean.github.io/Algorithms-and-Data-Structures-with-Python-2/



#### 시간 복잡도

우선 재귀적인 부분을 제외하면 `hanoi` 함수의 시간 복잡도는 O(1)입니다.

그렇다면 `hanoi` 함수가 얼만큼 호출되는지만 알면 될 텐데요. Recursive case를 살펴봅시다. `num_disks`를 n이라고 했을 때, n−1 크기의 부분 문제 2개를 만들어주고 있죠?

`hanoi` 함수는 `num_pegs`가 0이 될 때까지 계속해서 재귀적으로 더 작은 `hanoi` 호출을 하고, 계속해서 부분 문제를 2개씩 만들어 냅니다. `hanoi` 함수를 호출하게 되면, n번 만큼 부분 문제가 2배로 늘어나게 되는 거죠. 그렇기 때문에 총 시간 복잡도는 O(2^n) 이 됩니다.